#!/bin/bash
set -e

if [[ -z "$LOGPATH" ]]; then
    LOGPATH=/usr2/log
fi

if [[ -z "$PROCPATH" ]]; then
    PROCPATH=/usr2/proc
fi

#STATION = Two letter station code, eg "gs"
if [[ -z "$STATION" ]]; then
    >&2 echo "$0: ERROR: STATION enviroment variable not set; should be set to two-letter station code."
    exit 1
fi


pftp() {
    $DRY curl -n -T "$2" "ftp://$1/"
}
pscp() {
    $DRY scp "$2" "$1"
}

# Commands for Data Centers
CTR_CDDISFTP="pftp cddisin.gsfc.nasa.gov"
CTR_OPAR="pftp ivsopar.obspm.fr"
CTR_BKG="pftp ivs.bkg.bund.de"
CTR_HAYSTACK="pscp evlbi1.haystack.mit.edu:/data-st12/vgos/logs"
CTRS=$(compgen -A variable | grep CTR | cut -c 5- | paste -s -d" ")

# Default Data center
if [[ -z "$DATA_CENTERS" ]]; then
    DATA_CENTERS="CDDISFTP"
fi



usage(){
    cat <<EOF
Usage: $0 [-l] [-t] [-h] [-c CENTER] ARG ...
Push log file(s) to the data centers.
EOF
}
joinlst () { 
    local IFS=" "
    echo "$*" | sed 's/ /, /g' | sed 's/, \(\S*\)$/ or \1/g'
}

usage_long() {
    cat <<EOF
Usage: $0 [-l] [-t] [-h] [-c CENTER] ARG [ARG] ...
Push log file(s) to the data centers.

ARG can be an experiment ID or a file. Multiple arguments can be given.

Options
-l            Use latest log in $LOGPATH (other than 'station' or 'point').
              Other arguments are ignored.
-t            Test run, do not actually copy files to server
-h            Print this message
-c CENTER     Copy files to data CENTER. Overrides the DATA_CENTERS enviroment
              variable. Flag can be given multiple times.
-p            Also copy proc file

Data centers are specified in the DATA_CENTERS enviroment variable and can
contain $(joinlst $CTRS). The default is CDDISFTP.
Multiple centers are seperated with a space. Data centers must be configured in
"~/.netrc". See NETRC(5) for details.

$0 requires STATION enviroment variable to be set to two-letter id.

EOF
}


latest_log() {
    local log=$(ls -t $FSLOGPATH\
                | grep '\.log$'\
                | egrep -v '(station|point)'\
                | head -1)
    echo $FSLOGPATH/$log
}


while getopts hltpc: opt; do
    case $opt in
        l)
            log=$(latest_log)
            ;;
        t)
            DRY=echo
            ;;

        c) 
            if [[ ! $CTRS =~ $OPTARG ]]; then
                echo "Unknown data center '$OPTARG'" >&2
                exit 1
            fi
            CENTERS_OVER="$CENTERS_OVER $OPTARG"
            ;;
        p)
            COPY_PROC=1
            echo copying proc >&2
            ;;
        h)
            usage_long
            exit
            ;;
        *)
            usage >&2
            exit 1
            ;;
        :)
          echo "Option -$OPTARG requires an argument." >&2
          exit 1
          ;;
    esac
done

if [[ -n "$CENTERS_OVER" ]]; then
    DATA_CENTERS=$CENTERS_OVER
fi

shift $(($OPTIND - 1))

#If lastest not set and no arguments left, exit
if [[ -n "$log" ]]; then
    for center in $DATA_CENTERS; do
        eval \$CTR_$center $log
    done
    exit
fi

if [[ $# -eq 0 ]] ; then
    usage >&2
    exit 1
fi

lookup_log() {
    # if it looks like a path, return
    if [[ $1 =~ "^\.?\/]" ]]; then
        echo $1
        return
    fi
    # otherwise assume it's an expriment name
    echo $LOGPATH/$1$STATION.log
}

lookup_proc() {
    # if it's a path, don't lookup proc
    if [[ $1 =~ "^\.?\/]" ]]; then
        echo ""
        return
    fi
    # otherwise assume it's an expriment name
    echo $PROCPATH/$1$STATION.prc
}

while (( "$#" )); do
    log=$(lookup_log $1)
    if [[ ! -e $log ]]; then
        echo $log not found >&2
        exit 1
    fi
    if [[ -n "$COPY_PROC" ]]; then
        echo looking up $1$STATION.prc >&2
        proc=$(lookup_proc $1)
    fi

    for center in $DATA_CENTERS; do
        eval \$CTR_$center $log

        if [[ -e $proc ]]; then
            eval \$CTR_$center $proc
        fi
    done
    shift
done

