/*****************************************************************************
 *
 * FILE: check_prologix.c
 *
 *   Check the provided line coming from 'ibad.tcl' to see if it contains 
 *   a Prologix-controlled device --- if so, process it here.
 *
 *   Prologix-controlled devices are GPIB-devices which are controlled using
 *   TCP/IP communication with a Prologix GPIB-ethernet controller box instead
 *   of via a dedicated GPIB-card in the FS computer.
 *
 *   This version of IBCON allows you to mix and match between a GPIB-card,
 *   a Prologix-box controlling several devices on a common GPIB-bus,
 *   multiple GPIB-boxes each controlling a single GPIB-device or
 *   any combination of these options.
 *
 *   This procedure is part of the 'ibcon' program.
 *
 *   Prologix-controlled devices use the following syntax in the 'ibad.ctl'
 *   file:
 *
 *   MN=prologix,IP-address,command[;command[;command...]]
 *
 *   where 'MN' is the mnemonic used to identify the device, 'IP-address' is
 *   the IP-adress of the Prologix-box given in 'a.b.c.d' notation and the
 *   command sequence is the set commands to send when communicating with
 *   the device, which typically will include Prologix-commands used to set up
 *   the Prologix box as well as the GPIB-command to the device itself.
 *   Two special commands are recognized: '##' means that the GPIB-command
 *   passed to IBCON at the time of execution should be inserted at that point
 *   in the sequence, while '$$' means that the device has generated a reply
 *   that should be read at this point in the sequence.
 *
 *   Different commands can be sent to the same device by giving them different
 *   mnemonics, and for Prologix-controlled devices the mnemonic should be seen
 *   more as symbols for different actions instead of different devices.
 *
 *   At Onsala Space Observatory, we use two HP-devices for CABLE and CLOCK
 *   measurements, both being controlled by an individual Prologix-box.
 *   The 'ibad.ctl' file looks like this:
 *
 *   CA=prologix,192.16.6.15,++auto 0;++addr 2;++read_tmo_ms 1000;++read 10;$$
 *   CB=prologix,192.16.6.16,++addr 3;++auto 1;:READ?;$$;++auto 0;:INIT:CONT ON
 *
 *   The following example shows four mnemonics to talk to the same device:
 *   the first one is a standard read request, the second one is a reset
 *   command and the last two ones are for general commands and questions,
 *   respectively.
 *
 *   CB=prologix,192.16.6.16,++addr 3;++auto 1;:READ?;$$;++auto 0;:INIT:CONT ON
 *   CC=prologix,192.16.6.16,++addr 3;++auto 0;*RST
 *   CD=prologix,192.16.6.16,++addr 3;++auto 0;##
 *   CE=prologix,192.16.6.16,++addr 3;++auto 1;##;$$
 *
 * HISTORY
 *
 * who          when           what
 * ---------    -----------    ----------------------------------------------
 * lerner       26 Jul 2012    Original version
 *
 *****************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>



/*****************************************************************************
 *
 *   Macros
 *
 *****************************************************************************/

#define MAX_PROLOGIX                   50
#define MAX_SEQUENCES                  20



/*****************************************************************************
 *
 *   Global variables
 *
 *****************************************************************************/

/*  Prologix box variables  */

int prologix_boxes = 0;
char prologix_address[MAX_PROLOGIX][16];
int prologix_socket[MAX_PROLOGIX];

/*  Prologix device variables  */

int prologix_devices = 0;
char prologix_mnemonic[MAX_PROLOGIX][3];
char *prologix_sequence[MAX_PROLOGIX][MAX_SEQUENCES];
int prologix_box[MAX_PROLOGIX];



/*****************************************************************************
 *
 *   Subroutine declarations
 *
 *****************************************************************************/

int open_prologix(int box);
int close_prologix(int box);
int send_prologix(int device, char *buf, unsigned int timeout);
int read_prologix(int device, char *buf, size_t buf_len, unsigned int timeout);
int prologix_connected(int device);

int check_prologix__(char *line, int *length);



/*****************************************************************************
 *
 *   check_prologix
 *
 *     check the line from the ibad.ctl file --- return immediately with '0'
 *     if it is not a Prologix-controlled device, otherwise process the line
 *     and return the assigned index in the Prologix device tables or '-1'
 *     in case of an error
 *
 *****************************************************************************/

int check_prologix__(char *line, int *length) {

  char string[512], address[128], commands[512];
  char *p, *p1;
  int device, box;
  int i;

  logit(line, 0, NULL);

  /*  Return immediately, if this is not a Prologix-controlled device  */

  if ( strncmp(&line[3], "prologix", 8) != 0 )
    return(0);

  /*  Verify that we don't have too many Prologix-controlled devices  */

  if ( ++prologix_devices >= MAX_PROLOGIX ) {
    logit("Too many Prologix-devices declared in file ibad.ctl", 0, NULL);
    snprintf(string, sizeof(string), "Offending line: '%s'", line);
    logit(string, 0, NULL);
    return(-1);
  }

  /*  Store the mnemonic of the new Prologix-controlled device --- note that
      we don't use element '0' since we want positive numbers  */

  device = prologix_devices;

  strncpy(prologix_mnemonic[device], line, 2);
  prologix_mnemonic[device][2] = '\0';

  /*  Get the IP-address of the Prologix-box --- let's use strtok to split
      the string  */

  strncpy(string, line, sizeof(string));

  strtok(string, ",");

  if ( ( p = strtok(NULL, ",") ) == NULL ) {
    logit("No comma after word 'prologix' in file ibad.ctl", 0, NULL);
    snprintf(string, sizeof(string), "Offending line: '%s'", line);
    logit(string, 0, NULL);
    return(-1);
  }

  strncpy(address, p, sizeof(address));

  /*  Now get the command sequence from the string  */

  if ( ( p = strtok(NULL, ",") ) == NULL ) {
    logit("No comma after IP-address in file ibad.ctl", 0, NULL);
    snprintf(string, sizeof(string), "Offending line: '%s'", line);
    logit(string, 0, NULL);
    return(-1);
  }

  strncpy(commands, p, sizeof(commands));

  /*  Check if we already have registered this Prologix-box or if it is
      a new one  */

  box = -1;

  for ( i = 0 ; i < prologix_boxes ; i++ )
    if ( strcmp(prologix_address[i], address) == 0 )
      box = i;

  if ( box == -1 ) {
    if ( strlen(address) >= sizeof(prologix_address[0]) ) {
      logit("Bad IP-address in file ibad.ctl", 0, NULL);
      snprintf(string, sizeof(string), "Offending line: '%s'", line);
      logit(string, 0, NULL);
      return(-1);
    }
    box = prologix_boxes++;
    strcpy(prologix_address[box], address);
    if ( open_prologix(box) < 0 ) {
      snprintf(string, sizeof(string), "Failed to open socket to Prologix-box "
	       "at '%s' for device '%s'", prologix_address[box],
	       prologix_mnemonic[device]);
      logit(string, 0, NULL);
      logit("ERROR", errno, "un");
    }
  }

  prologix_box[device] = box;

  /*  Split up and store the Prologix command sequence  */

  p1 = commands;
  i = 0;

  while ( ( p = strtok(p1, ";") ) != NULL ) {
    if ( i + 1 >= MAX_SEQUENCES ) {
      logit("Too many commands for device in file ibad.ctl", 0, NULL);
      snprintf(string, sizeof(string), "Offending line: '%s'", line);
      logit(string, 0, NULL);
      return(-1);
    }
    prologix_sequence[device][i] = (char *) malloc(strlen(p) + 1);
    strcpy(prologix_sequence[device][i++], p);
    p1 = NULL;
  }

  prologix_sequence[device][i] = NULL;

  /*  Write a message to the log  */

  sprintf(string, "initiated GPIB-device %s on Prologix %s (%d commands)",
	  prologix_mnemonic[device], prologix_address[box], i);
  logit(string, 0, NULL);

  return(device);
}
