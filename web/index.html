<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="node_modules/xterm/dist/xterm.css" />
    <script src="node_modules/xterm/dist/xterm.js"></script>
    <script src="node_modules/nanomsg-browser/src/nanomsg.js" charset="utf-8"></script>
</head>

<style>
#terminal .content {
    white-space: pre;
    font-family: monospace;
}

#terminal {
    width: 80ch;
    height: 50vh;
    color: green;
    background-color: black;
    overflow-y: scroll;
}
#terminal * {
    overflow-anchor: none;
}

#terminal .anchor {
    overflow-anchor: auto;
    height: 1px;
}

body{
    margin: 0;
    padding: 0;
}

</style>

<body>
    <div id="terminal">
        <div class="content"></div>
        <div class="anchor"></div>
    </div>
    <script>

(function(){
    'use strict';

    const type = {
        DATA: Symbol("DATA"),
        HEARTBEAT: Symbol("HEARTBEAT"),
        END_OF_SESSION: Symbol("END_OF_SESSION"),
    }


    function type_unmarshal(t) {
        switch (t) {
        case 0:
            return type.DATA;
        case 1:
            return type.HEARTBEAT;
        case 2: 
            return type.HEARTBEAT;
        }

    }


    function newSubClient(url, on) {
        let ssubClient = { url: url, state: "INIT", fetchBacklog: true, seq: 0, continueAfterShutdown: true };

    }

    let utf8decoder = new TextDecoder();

    function msg_unmarshal(buffer) {
        let view = new DataView(buffer);
        let msg = {};

        let bytes = 0;
        msg.type = type_unmarshal(view.getUint8(bytes));
        bytes += 1;
        msg.seq = view.getBigUint64(bytes, true);
        bytes += 8;

        if (msg.type != type.DATA) {
            return [msg, bytes];
        }

        let len = view.getUint16(bytes, true);
        bytes += 2;
        if (len == 0) return [msg, bytes];
        // TODO: probably don't want to decode here
        msg.data = utf8decoder.decode(buffer.slice(bytes, bytes+len));
        bytes += len
        return [msg, bytes];
    }

    function msgs_unmarshal(buffer) {
        let msgs = [];
        while (buffer.byteLength > 0) {
            let [msg, bytes] = msg_unmarshal(buffer);
            msgs.push(msg);
            buffer = buffer.slice(bytes);
        }
        return msgs;
    }

    // I don't like that this is a global and not per socket
    nanomsg.receiveArrayBuffer = true;
    nanomsg.debug = true;

    var loc = window.location, new_uri;
    if (loc.protocol === "https:") {
        new_uri = "wss:";
    } else {
        new_uri = "ws:";
    }
    new_uri += "//" + loc.host;
    new_uri += loc.pathname;

    const subaddr = new_uri + "socks/pub";
    const repaddr = new_uri + "socks/rep";

    // var term = new Terminal();
    // term.open();

    let content = document.querySelectorAll("#terminal .content")[0]

	// sequence id of the next msg we're expecting to receive
    let seq = BigInt(0);
	let hanled_timeout = false;
	let synced = false; // state of client
    let perform_first_sync = true;
    let exit_on_terminate_msg = true;

    //TODO: hanlde timeout

    let syncing = false
    let queue = []

    const max_nodes = 1000;
    function callback(msg) {
        if (!msg) {
            throw "msg empy";
        }
        content.appendChild(document.createTextNode(msg.data));
        if (content.childNodes.length > max_nodes) {
            content.removeChild(content.firstChild);
        }
    }

    const sub = new nanomsg.Socket(nanomsg.SUB);
    sub.connect(subaddr);
    sub.on('data', async (rawmsg) => {
        let [m, nbytes] = msg_unmarshal(rawmsg);

        if (syncing) {
            queue.push(m);
            return;
        }

		if (!perform_first_sync) {
			perform_first_sync = true;
			synced             = true;
			seq                = m.seq;
		}

		if (m.type == type.END_OF_SESSION) {
			if (m.seq > seq) {
                // TODO: check if need to do more.
				seq =  await sync_msgs(seq, repaddr, 1000);
			}
            if (exit_on_terminate_msg) {
                // TODO: close conn
				return;
            }
            return
        }


		if (m.seq < seq) {
			if (!synced) {
				// Ignore msgs we've already seen. This may happen during re-sync as
				// msgs received by OOB sync may also arrive at sub socket
				return;
			}
			// If we're not rsyncing and we see a message with lower seq than we expect,
			// the server may have restarted, and we need to resync right from the
			// start.
			seq = BigInt(0);
		}

		if (m.seq > seq) {
			// We've missed a message, perform out-of-band sync
            syncing = true;
			synced  = false;
            let s = await sync_msgs(seq, repaddr, -1);
			// We may have gotten fewer or more messages than we were expecting.
			// If we got more next, we ensure
			// TODO: we should check if we got less here and do another resync

			seq = s + BigInt(1);
            console.log(queue);
            for (let m of queue) {
                if (m.seq != seq || m.type != type.DATA) {
                    continue
                }
                callback(m);
                seq = m.seq + BigInt(1);
            }
            queue = [];
            syncing = false;

			return;
		}

		if (!synced && m.seq == seq) {
			synced = true;
		}

		if (m.type == type.HEARTBEAT) {
			return;
		}

        callback(m);
		seq = m.seq + BigInt(1);
        // term.write(msg.data);
        // term.write('\r');
    });

    async function sync_msgs(seq, addr, timeout) {
        const req = new nanomsg.Socket(nanomsg.REQ);
        try {
            await req.connect(addr);
        } catch {
            console.log("conn");
            return 0;
        }

        const buf = new ArrayBuffer(8);
        const view = new DataView(buf);

        view.setBigUint64(0, seq);
        const data = await req.send(buf);
        const msgs = msgs_unmarshal(data);
        for (const m of msgs) {
            callback(m);
        }
        return msgs[msgs.length - 1].seq;
    }

})()
    </script>
</body>

</html>
